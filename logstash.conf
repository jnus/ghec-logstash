# GitHub Enterprise Cloud (GHEC) Webhook Logstash Configuration
# Processes all GitHub.com webhook payloads as documented at:
# https://docs.github.com/en/webhooks/webhook-events-and-payloads

input {
  http {
    port => 8080
    codec => json
    additional_codecs => { "application/json" => "json" }
    ecs_compatibility => disabled
    tags => ["github_webhook"]
  }
}

filter {
  # Only process GitHub webhook events
  if "github_webhook" in [tags] {
    
    # Handle form-encoded GitHub webhooks
    if "_jsonparsefailure" in [tags] {
      # Remove the JSON parse failure tag
      mutate {
        ecs_compatibility => disabled
        remove_tag => ["_jsonparsefailure"]
      }
      
      # Parse URL-encoded form data
      kv {
        source => "message"
        field_split => "&"
        value_split => "="
        target => "form_data"
      }
      
      # URL decode and parse the payload JSON
      if [form_data][payload] {
        urldecode {
          field => "[form_data][payload]"
        }
        
        json {
          source => "[form_data][payload]"
          target => "webhook_data"
        }
        
        # Copy webhook data to root level for easier processing
        ruby {
          code => "
            webhook_data = event.get('webhook_data')
            if webhook_data.is_a?(Hash)
              webhook_data.each do |key, value|
                event.set(key, value)
              end
            end
          "
        }
        
        # Clean up temporary fields
        mutate {
          ecs_compatibility => disabled
          remove_field => ["form_data", "webhook_data", "message"]
        }
      }
    }
    
    # Add timestamp and event metadata
    mutate {
      ecs_compatibility => disabled
      add_field => {
        "[@metadata][processed_at]" => "%{+yyyy-MM-dd'T'HH:mm:ss.SSSZ}" 
      }
    }
    
    # Try to get event type from headers, fallback to inference from payload
    if [@metadata][input][http][request][headers][x-github-event] {
      mutate {
        ecs_compatibility => disabled
        add_field => {
          "event_type" => "%{[@metadata][input][http][request][headers][x-github-event]}"
        }
      }
    } else if [zen] {
      # GitHub ping event
      mutate {
        ecs_compatibility => disabled
        add_field => { "event_type" => "ping" }
      }
    } else if [commits] and [after] and [before] {
      # Push event
      mutate {
        ecs_compatibility => disabled
        add_field => { "event_type" => "push" }
      }
    } else if [pull_request] {
      # Pull request event
      mutate {
        ecs_compatibility => disabled
        add_field => { "event_type" => "pull_request" }
      }
    } else if [issue] {
      # Issue event
      mutate {
        ecs_compatibility => disabled
        add_field => { "event_type" => "issues" }
      }
    } else if [release] {
      # Release event
      mutate {
        ecs_compatibility => disabled
        add_field => { "event_type" => "release" }
      }
    } else {
      # Unknown event type
      mutate {
        ecs_compatibility => disabled
        add_field => { "event_type" => "unknown" }
      }
    }
    
    # Try to get delivery ID from headers
    if [@metadata][input][http][request][headers][x-github-delivery] {
      mutate {
        ecs_compatibility => disabled
        add_field => {
          "delivery_id" => "%{[@metadata][input][http][request][headers][x-github-delivery]}"
        }
      }
    }
    
    # Extract common repository information
    if [repository] {
      mutate {
        ecs_compatibility => disabled
        add_field => {
          "repo_name" => "%{[repository][name]}"
          "repo_full_name" => "%{[repository][full_name]}"
          "repo_id" => "%{[repository][id]}"
          "repo_owner" => "%{[repository][owner][login]}"
          "repo_private" => "%{[repository][private]}"
          "repo_default_branch" => "%{[repository][default_branch]}"
        }
      }
    }
    
    # Extract sender information
    if [sender] {
      mutate {
        ecs_compatibility => disabled
        add_field => {
          "sender_login" => "%{[sender][login]}"
          "sender_id" => "%{[sender][id]}"
          "sender_type" => "%{[sender][type]}"
        }
      }
    }
    
    # Extract organization information if present
    if [organization] {
      mutate {
        ecs_compatibility => disabled
        add_field => {
          "org_login" => "%{[organization][login]}"
          "org_id" => "%{[organization][id]}"
        }
      }
    }
    
    # Handle specific event types with additional parsing
    
    # Push events
    if [event_type] == "push" {
      mutate {
        ecs_compatibility => disabled
        add_field => {
          "ref" => "%{[ref]}"
          "before_sha" => "%{[before]}"
          "after_sha" => "%{[after]}"
          "created" => "%{[created]}"
          "deleted" => "%{[deleted]}"
          "forced" => "%{[forced]}"
          "compare_url" => "%{[compare]}"
        }
      }
      
      # Count commits
      if [commits] {
        ruby {
          code => "event.set('commit_count', event.get('commits').length)"
        }
      }
    }
    
    # Pull Request events
    else if [event_type] == "pull_request" {
      mutate {
        ecs_compatibility => disabled
        add_field => {
          "action" => "%{[action]}"
          "pr_number" => "%{[pull_request][number]}"
          "pr_state" => "%{[pull_request][state]}"
          "pr_title" => "%{[pull_request][title]}"
          "pr_draft" => "%{[pull_request][draft]}"
          "pr_mergeable" => "%{[pull_request][mergeable]}"
          "pr_base_ref" => "%{[pull_request][base][ref]}"
          "pr_head_ref" => "%{[pull_request][head][ref]}"
        }
      }
    }
    
    # Issues events
    else if [event_type] == "issues" {
      mutate {
        ecs_compatibility => disabled
        add_field => {
          "action" => "%{[action]}"
          "issue_number" => "%{[issue][number]}"
          "issue_state" => "%{[issue][state]}"
          "issue_title" => "%{[issue][title]}"
        }
      }
    }
    
    # Release events
    else if [event_type] == "release" {
      mutate {
        ecs_compatibility => disabled
        add_field => {
          "action" => "%{[action]}"
          "release_tag" => "%{[release][tag_name]}"
          "release_name" => "%{[release][name]}"
          "release_draft" => "%{[release][draft]}"
          "release_prerelease" => "%{[release][prerelease]}"
        }
      }
    }
    
    # Repository events
    else if [event_type] == "repository" {
      mutate {
        ecs_compatibility => disabled
        add_field => {
          "action" => "%{[action]}"
        }
      }
    }
    
    # Star events
    else if [event_type] == "star" {
      mutate {
        ecs_compatibility => disabled
        add_field => {
          "action" => "%{[action]}"
          "starred_at" => "%{[starred_at]}"
        }
      }
    }
    
    # Fork events
    else if [event_type] == "fork" {
      mutate {
        ecs_compatibility => disabled
        add_field => {
          "forkee_name" => "%{[forkee][full_name]}"
          "forkee_id" => "%{[forkee][id]}"
        }
      }
    }
    
    # Watch events
    else if [event_type] == "watch" {
      mutate {
        ecs_compatibility => disabled
        add_field => {
          "action" => "%{[action]}"
        }
      }
    }
    
    # Create events (branch or tag creation)
    else if [event_type] == "create" {
      mutate {
        ecs_compatibility => disabled
        add_field => {
          "ref_type" => "%{[ref_type]}"
          "ref" => "%{[ref]}"
          "master_branch" => "%{[master_branch]}"
        }
      }
    }
    
    # Delete events (branch or tag deletion)
    else if [event_type] == "delete" {
      mutate {
        ecs_compatibility => disabled
        add_field => {
          "ref_type" => "%{[ref_type]}"
          "ref" => "%{[ref]}"
        }
      }
    }
    
    # Clean up headers that are no longer needed
    mutate {
      ecs_compatibility => disabled
      remove_field => ["headers"]
    }
    
    # Add final processing timestamp
    date {
      match => [ "[@metadata][processed_at]", "yyyy-MM-dd'T'HH:mm:ss.SSSZ" ]
      target => "@timestamp"
      ecs_compatibility => disabled
    }
  }
}

output {
  # Output to Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "github-webhooks-%{+YYYY.MM.dd}"
    template_name => "github-webhooks"
  }
  
  # Output to stdout for debugging (comment out in production)
  stdout {
    codec => rubydebug {
      metadata => true
    }
  }
  
  # Optional: Output to file for archival
  # file {
  #   path => "/var/log/logstash/github-webhooks.log"
  #   codec => json_lines
  # }
}