# GitHub Enterprise Cloud (GHEC) Webhook Logstash Configuration
# Processes all GitHub.com webhook payloads as documented at:
# https://docs.github.com/en/webhooks/webhook-events-and-payloads

input {
  http {
    port => 8080
    codec => json
    additional_codecs => { "application/json" => "json" }
    ecs_compatibility => disabled
    tags => ["github_webhook"]
    # Enable storing headers in the event
    additional_codecs => { 
      "application/json" => "json"
      "application/x-www-form-urlencoded" => "plain"
    }
  }
}

filter {
  # Only process GitHub webhook events
  if "github_webhook" in [tags] {
    
    # Handle form-encoded GitHub webhooks
    if "_jsonparsefailure" in [tags] {
      # Remove the JSON parse failure tag
      mutate {
        ecs_compatibility => disabled
        remove_tag => ["_jsonparsefailure"]
      }
      
      # Parse URL-encoded form data
      kv {
        source => "message"
        field_split => "&"
        value_split => "="
        target => "form_data"
      }
      
      # URL decode and parse the payload JSON
      if [form_data][payload] {
        urldecode {
          field => "[form_data][payload]"
        }
        
        json {
          source => "[form_data][payload]"
          target => "webhook_data"
        }
        
        # Copy webhook data to root level for easier processing
        ruby {
          code => "
            webhook_data = event.get('webhook_data')
            if webhook_data.is_a?(Hash)
              webhook_data.each do |key, value|
                event.set(key, value)
              end
            end
          "
        }
        
        # Clean up temporary fields
        mutate {
          ecs_compatibility => disabled
          remove_field => ["form_data", "webhook_data", "message"]
        }
      }
    }
    
    # Add timestamp and event metadata
    mutate {
      ecs_compatibility => disabled
      add_field => {
        "[@metadata][processed_at]" => "%{+yyyy-MM-dd'T'HH:mm:ss.SSSZ}" 
      }
    }
    
    # Extract GitHub headers using Ruby for more reliable access
    ruby {
      code => "
        # Try to get headers from various possible locations
        headers = nil
        
        # Check different possible header locations
        if event.get('[@metadata][input][http][request][headers]')
          headers = event.get('[@metadata][input][http][request][headers]')
        elsif event.get('[headers]')
          headers = event.get('[headers]')
        elsif event.get('[@metadata][http_request_headers]')
          headers = event.get('[@metadata][http_request_headers]')
        end
        
        # Also check if headers are in the top-level fields (common with HTTP input)
        if !headers
          # Look for headers that might be at the root level
          all_fields = event.to_hash
          headers = {}
          all_fields.each do |key, value|
            if key.downcase.start_with?('x_github_') || key.downcase == 'content_type' || key.downcase == 'user_agent'
              headers[key.downcase] = value
            end
          end
          headers = nil if headers.empty?
        end
        
        if headers
          # Extract GitHub Event header (handle Logstash name conversion: x-github-event -> x_github_event)
          github_event = headers['x_github_event'] || headers['x-github-event'] || headers['X-GitHub-Event'] || headers['X-Github-Event']
          if github_event
            event.set('event_type', github_event)
          end
          
          # Extract GitHub Delivery ID header (handle Logstash name conversion: x-github-delivery -> x_github_delivery)
          delivery_id = headers['x_github_delivery'] || headers['x-github-delivery'] || headers['X-GitHub-Delivery'] || headers['X-Github-Delivery']
          if delivery_id
            event.set('delivery_id', delivery_id)
          end
          
          # Store headers for debugging (optional)
          event.set('[@metadata][debug_headers]', headers.keys.join(','))
        else
          event.set('[@metadata][debug_headers]', 'no_headers_found')
        end
      "
    }
    
    # Fallback to content-based event type detection if header extraction failed
    if ![event_type] {
      if [zen] {
        # GitHub ping event
        mutate {
          ecs_compatibility => disabled
          add_field => { "event_type" => "ping" }
        }
      } else if [commits] and [after] and [before] {
        # Push event
        mutate {
          ecs_compatibility => disabled
          add_field => { "event_type" => "push" }
        }
      } else if [pull_request] {
        # Pull request event
        mutate {
          ecs_compatibility => disabled
          add_field => { "event_type" => "pull_request" }
        }
      } else if [issue] {
        # Issue event
        mutate {
          ecs_compatibility => disabled
          add_field => { "event_type" => "issues" }
        }
      } else if [release] {
        # Release event
        mutate {
          ecs_compatibility => disabled
          add_field => { "event_type" => "release" }
        }
      } else {
        # Unknown event type
        mutate {
          ecs_compatibility => disabled
          add_field => { "event_type" => "unknown" }
        }
      }
    }
    
    # Extract common repository information
    if [repository][name] {
      mutate {
        ecs_compatibility => disabled
        add_field => { "repo_name" => "%{[repository][name]}" }
      }
    }
    
    if [repository][full_name] {
      mutate {
        ecs_compatibility => disabled
        add_field => { "repo_full_name" => "%{[repository][full_name]}" }
      }
    }
    
    if [repository][id] {
      mutate {
        ecs_compatibility => disabled
        add_field => { "repo_id" => "%{[repository][id]}" }
      }
    }
    
    if [repository][owner][login] {
      mutate {
        ecs_compatibility => disabled
        add_field => { "repo_owner" => "%{[repository][owner][login]}" }
      }
    }
    
    if [repository][private] {
      mutate {
        ecs_compatibility => disabled
        add_field => { "repo_private" => "%{[repository][private]}" }
      }
    }
    
    if [repository][default_branch] {
      mutate {
        ecs_compatibility => disabled
        add_field => { "repo_default_branch" => "%{[repository][default_branch]}" }
      }
    }
    
    # Extract sender information
    if [sender][login] {
      mutate {
        ecs_compatibility => disabled
        add_field => { "sender_login" => "%{[sender][login]}" }
      }
    }
    
    if [sender][id] {
      mutate {
        ecs_compatibility => disabled
        add_field => { "sender_id" => "%{[sender][id]}" }
      }
    }
    
    if [sender][type] {
      mutate {
        ecs_compatibility => disabled
        add_field => { "sender_type" => "%{[sender][type]}" }
      }
    }
    
    # Extract organization information if present
    if [organization][login] {
      mutate {
        ecs_compatibility => disabled
        add_field => { "org_login" => "%{[organization][login]}" }
      }
    }
    
    if [organization][id] {
      mutate {
        ecs_compatibility => disabled
        add_field => { "org_id" => "%{[organization][id]}" }
      }
    }
    
    # Handle specific event types with additional parsing
    
    # Push events
    if [event_type] == "push" {
      # Only add fields that exist in the payload
      if [ref] {
        mutate {
          ecs_compatibility => disabled
          add_field => { "ref" => "%{[ref]}" }
        }
      }
      
      if [before] {
        mutate {
          ecs_compatibility => disabled
          add_field => { "before_sha" => "%{[before]}" }
        }
      }
      
      if [after] {
        mutate {
          ecs_compatibility => disabled
          add_field => { "after_sha" => "%{[after]}" }
        }
      }
      
      if [created] {
        mutate {
          ecs_compatibility => disabled
          add_field => { "created" => "%{[created]}" }
        }
      }
      
      if [deleted] {
        mutate {
          ecs_compatibility => disabled
          add_field => { "deleted" => "%{[deleted]}" }
        }
      }
      
      if [forced] {
        mutate {
          ecs_compatibility => disabled
          add_field => { "forced" => "%{[forced]}" }
        }
      }
      
      if [compare] {
        mutate {
          ecs_compatibility => disabled
          add_field => { "compare_url" => "%{[compare]}" }
        }
      }
      
      # Count commits
      if [commits] {
        ruby {
          code => "
            commits = event.get('commits')
            if commits && commits.is_a?(Array)
              event.set('commit_count', commits.length)
            end
          "
        }
      }
    }
    
    # Pull Request events
    else if [event_type] == "pull_request" {
      mutate {
        ecs_compatibility => disabled
        add_field => {
          "action" => "%{[action]}"
          "pr_number" => "%{[pull_request][number]}"
          "pr_state" => "%{[pull_request][state]}"
          "pr_title" => "%{[pull_request][title]}"
          "pr_draft" => "%{[pull_request][draft]}"
          "pr_mergeable" => "%{[pull_request][mergeable]}"
          "pr_base_ref" => "%{[pull_request][base][ref]}"
          "pr_head_ref" => "%{[pull_request][head][ref]}"
        }
      }
    }
    
    # Issues events
    else if [event_type] == "issues" {
      if [action] {
        mutate {
          ecs_compatibility => disabled
          add_field => { "action" => "%{[action]}" }
        }
      }
      
      if [issue][number] {
        mutate {
          ecs_compatibility => disabled
          add_field => { "issue_number" => "%{[issue][number]}" }
        }
      }
      
      if [issue][state] {
        mutate {
          ecs_compatibility => disabled
          add_field => { "issue_state" => "%{[issue][state]}" }
        }
      }
      
      if [issue][title] {
        mutate {
          ecs_compatibility => disabled
          add_field => { "issue_title" => "%{[issue][title]}" }
        }
      }
    }
    
    # Issue comment events
    else if [event_type] == "issue_comment" {
      if [action] {
        mutate {
          ecs_compatibility => disabled
          add_field => { "action" => "%{[action]}" }
        }
      }
      
      if [issue][number] {
        mutate {
          ecs_compatibility => disabled
          add_field => { "issue_number" => "%{[issue][number]}" }
        }
      }
      
      if [comment][id] {
        mutate {
          ecs_compatibility => disabled
          add_field => { "comment_id" => "%{[comment][id]}" }
        }
      }
      
      if [comment][body] {
        mutate {
          ecs_compatibility => disabled
          add_field => { "comment_body" => "%{[comment][body]}" }
        }
      }
    }
    
    # Release events
    else if [event_type] == "release" {
      mutate {
        ecs_compatibility => disabled
        add_field => {
          "action" => "%{[action]}"
          "release_tag" => "%{[release][tag_name]}"
          "release_name" => "%{[release][name]}"
          "release_draft" => "%{[release][draft]}"
          "release_prerelease" => "%{[release][prerelease]}"
        }
      }
    }
    
    # Repository events
    else if [event_type] == "repository" {
      mutate {
        ecs_compatibility => disabled
        add_field => {
          "action" => "%{[action]}"
        }
      }
    }
    
    # Star events
    else if [event_type] == "star" {
      mutate {
        ecs_compatibility => disabled
        add_field => {
          "action" => "%{[action]}"
          "starred_at" => "%{[starred_at]}"
        }
      }
    }
    
    # Fork events
    else if [event_type] == "fork" {
      mutate {
        ecs_compatibility => disabled
        add_field => {
          "forkee_name" => "%{[forkee][full_name]}"
          "forkee_id" => "%{[forkee][id]}"
        }
      }
    }
    
    # Watch events
    else if [event_type] == "watch" {
      mutate {
        ecs_compatibility => disabled
        add_field => {
          "action" => "%{[action]}"
        }
      }
    }
    
    # Create events (branch or tag creation)
    else if [event_type] == "create" {
      mutate {
        ecs_compatibility => disabled
        add_field => {
          "ref_type" => "%{[ref_type]}"
          "ref" => "%{[ref]}"
          "master_branch" => "%{[master_branch]}"
        }
      }
    }
    
    # Delete events (branch or tag deletion)
    else if [event_type] == "delete" {
      mutate {
        ecs_compatibility => disabled
        add_field => {
          "ref_type" => "%{[ref_type]}"
          "ref" => "%{[ref]}"
        }
      }
    }
    
    # Clean up headers that are no longer needed
    mutate {
      ecs_compatibility => disabled
      remove_field => ["headers"]
    }
    
    # Add final processing timestamp
    date {
      match => [ "[@metadata][processed_at]", "yyyy-MM-dd'T'HH:mm:ss.SSSZ" ]
      target => "@timestamp"
      ecs_compatibility => disabled
    }
  }
}

output {
  # Output to Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "github-webhooks-%{+YYYY.MM.dd}"
    template_name => "github-webhooks"
  }
  
  # Output to stdout for debugging (comment out in production)
  stdout {
    codec => rubydebug {
      metadata => true
    }
  }
  
  # Optional: Output to file for archival
  # file {
  #   path => "/var/log/logstash/github-webhooks.log"
  #   codec => json_lines
  # }
}